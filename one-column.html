<!doctype html>
<html lang="en">
	<head>
        <title>Home</title>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <!-- Main CSS --> 
        <link rel="stylesheet" href="css/style.css">

        <!-- Font Awesome -->
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    </head>
  
    <body>

        <!-- Header -->
        <div class="header-wrap d-none d-md-block" id="top">
            <div class="container">
                <div class="row">
                    
                    <!-- Left header box -->
                    <header class="col-6 text-left">
                        <h1>算法学习</h1>
                    </header>
                </div>
            </div>
        </div>

        
        <!-- Main navigation -->
        <nav class="navbar navbar-expand-md navbar-dark bg-primary">
            <div class="container">
                
                <!-- Company name shown on mobile -->
                <a class="navbar-brand d-md-none d-lg-none d-xl-none" href="#">My Blog</a>

                <!-- Mobile menu toggle -->
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#mainNavbar" aria-controls="mainNavbar" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Main navigation items -->
                <div class="collapse navbar-collapse" id="mainNavbar">
                    <ul class="navbar-nav mr-auto">
                        <li class="nav-item ">
                                <a class="nav-link" href="index.html">主页 <span class="sr-only">(current)</span></a>
                        </li>

                        <li class="nav-item active">
                                <a class="nav-link" href="one-column.html">算法学习</a>
                        </li>

                        <li class="nav-item">
                                <a class="nav-link" href="#">数据库学习</a>
                        </li>

                        <li class="nav-item">
                                <a class="nav-link" href="#">操作系统</a>
                        </li>
						<li class="nav-item">
                                <a class="nav-link" href="#">计算机网络</a>
                        </li>
                    </ul>
                    <!--form class="form-inline header-search-form my-2 my-lg-0">
                        <input class="form-control mr-sm-2" type="text" size="10"  placeholder="Search" aria-label="Search">
                        <button class="btn btn-secondary my-2 my-sm-0" type="submit">Search</button>
                    </form-->
                </div>                
            </div>
        </nav>


        <!--Jumbtron / Slider >
        <div class="jumbotron-wrap">
            <div class="container">
                <div class="jumbotron">
                    <h1 class="text-center">Enjoy Learning</h1>
                </div>
            </div>
        </div>

        <!-- Main content area -->
        <main class="container">
            <div class="row">
             
                <!-- Main content-->
                <div class="col">
                    <article>
						<h1>数据库</h1>
						<h4>1、事务的四大特性（ACID）</h4>
						<p>事务的概念：访问并可能更新数据库中各种数据项的一个程序执行单元（unit），它通常由高级数据库操纵语言或编程语言（如SQL，C++或Java）书写的用户程序的执行所引起。<code>当在数据库中更改数据成功时</code>，在事务中更改的数据便会提交，不再改变。否则，事务就取消或者回滚，更改无效。</p>
						<p><strong>原子性：</strong>事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。</p>
						<p><strong>隔离性：</strong>并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的。</p>
						<p><strong>持久性：</strong>一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p>
						<p><strong>一致性：</strong>执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。</p>
						<h4>2、数据库隔离级别</h4>
						<p>并发事务出现的问题：</p>
						<p><strong>脏读</strong>：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p>
						<p><strong>不可重复读</strong>：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
						<p><strong>幻读</strong>：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
						<p>隔离级别：</p>
						<p><strong>读未提交</strong>：最低隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p>
						<p><strong>读已提交</strong>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍可能发生。</p>
						<p><strong>可重复读</strong>：对同一字段的多次读取结果是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p>
						<p><strong>可串行化</strong>：最高隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p>
						<figure><table>
						<thead>
						<tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead>
						<tbody><tr><td>读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读已提交</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读</td><td>×</td><td>×</td><td>√</td></tr><tr><td>可串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody>
						</table></figure>
						<h4>3、MYSQL的两种存储引擎比较</h4>
						<p>MyISAM更适合读密集的表，而InnoDB更适合写密集的的表。 在数据库做主从分离的情况下，经常选择MyISAM作为主库的存储引擎。</p>
						<p>一般来说，如果需要事务支持，并且有较高的并发读取频率(MyISAM的表锁的粒度太大，所以当该表写并发量较高时，要等待的查询就会很多了)，InnoDB是不错的选择。如果你的数据量很大（MyISAM支持压缩特性可以减少磁盘的空间占用），而且不需要支持事务MyISAM是最好的选择。</p>

						<h5>3.1、MyISAM（非聚簇索引）</h5>
						<p>MyISAM是MySQL的默认数据库引擎（5.5版）之前，由早期的ISAM（Indexed Sequential Access Method：有索引的顺序访问方法）所改良。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的优点就是奔溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（另一种数据库引擎）。</p>
						<ul>
						<li>不支持行锁(MyISAM只有表锁)，读取时对需要读到的所有表加锁，写入时则对表加排他锁；</li>
						<li>不支持事务</li>
						<li>不支持外键</li>
						<li>不支持崩溃后的安全恢复</li>
						<li>在表有读取查询的同时，支持往表中插入新纪录</li>
						<li>支持BLOB和TEXT的前500个字符索引，支持全文索引</li>
						<li>支持延迟更新索引，极大地提升了写入性能</li>
						<li>对于不会进行修改的表，支持 压缩表 ，极大地减少了磁盘空间的占用</li>

						</ul>
						<h5>3.2、InnoDB（聚簇索引）</h5>
						<p>InnoDB是事务安全的MySQL存储引擎，支持ACID</p>
						<ul>
						<li>支持行锁，采用MVCC来支持高并发，有可能死锁</li>
						<li>支持事务</li>
						<li>支持外键</li>
						<li>支持崩溃后的安全恢复</li>
						<li>不支持全文索引</li>

						</ul>
						<p><strong>3.3、二者常见对比</strong></p>
						<p>1) count运算上的区别： 因为MyISAM缓存有表meta-data（行数等），因此在做COUNT(*)时对于一个结构很好的查询是不需要消耗多少资源的。而对于InnoDB来说，则没有这种缓存。</p>
						<p>2) 是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</p>
						<p>3)是否支持外键： MyISAM不支持，而InnoDB支持。</p>
						<h4>4、数据库索引</h4>
						<p>数据库索引本质上是一种数据结构(存储结构+算法)，目的是为了加快目标数据检索的速度。</p>
						<p><strong>优点：</strong></p>
						<p>1）大大加快数据的检索速度
						2）创建唯一性索引,可以保证数据库每一行数据的唯一性
						3）加速表与表之间的连接
						4）在使用分组和排序子句进行数据库检索时,可以显著减少查询分组和排序的维护速度</p>
						<p><strong>缺点：</strong></p>
						<p>1）创建索引需要占用物理空间
						2）对表中数据进行增删改,索引需要从新计算,消耗性能.</p>
						<h5><strong>索引分类</strong></h5>
						<p><strong>按逻辑角度分</strong></p>
						<ul>
						<li>普通索引：最基本的索引，没有任何限制</li>

						</ul>
						<p>       <strong>CREATE INDEX index_name ON table(column(length))</strong></p>
						<ul>
						<li><p>唯一索引:确保数据唯一性</p>
						<p><strong>CREATE UNIQUE INDEX index_name ON table(column(length))</strong></p>
						</li>
						<li><p>主键索引:是唯一索引的特定类型,创建主键时自动创建</p>
						<pre><code>CREATE TABLE table (
							 id int(11) NOT NULL AUTO_INCREMENT ,
							 title char(255) NOT NULL,
							 PRIMARY KEY (id)
						);
						</code></pre>
						</li>
						<li><p>组合索引: 多个字段上建立的索引，提高复合条件查询的速度</p>
						<p><strong>create index index_name_age on student(name,age)</strong></p>
						</li>

						</ul>
						<p><strong>按物理存储分</strong></p>
						<p>聚集索引</p>
						<p>表记录的排列顺序和索引的排列顺序一致,所以查询效率快,只要找到第一个索引值记录,其余连续性的记录在物理上一样连续存放.聚集索引的缺点就是修改慢,因为为了使表记录和索引的排列顺序一致,在插入记录的时候,会对数据页重新排序</p>
						<p>非聚集索引</p>
						<p>表记录和索引的排列顺序不一定一致,两种索引都采用B+树的结构,非聚集索引的叶子层并不和实际数据页相重叠,而采用叶子层包含一个指向表记录的指针.非聚集索引层次多,不会造成数据重排</p>
						<p>聚簇索引:</p>
						<ul>
						<li>优点: 查询速度快,主键和索引在一个结构里.</li>
						<li>缺点: 对表进行修改速度慢,插入新纪录要从排,维持B+树特性二频繁分裂调整,十分低效.</li>
						<li>场景:要取出一定范围的数据时;无需插入新值时.</li>

						</ul>
						<p>非聚簇索引:</p>
						<ul>
						<li>优点:添加纪录不会引起数顺序重排.</li>
						<li>场合:频繁更新的列;</li>

						</ul>
						<h5><strong>索引创建说明</strong></h5>
						<p>①经常需要搜索的列上</p>
						<p>②作为主键的列上</p>
						<p>③经常用在连接的列上,这些列主要是一些外键,可以加快连接的速度</p>
						<p>④经常需要根据范围进行搜索的列上</p>
						<p>⑤经常需要排序的列上</p>
						<p>⑥经常使用在where子句上面的列上</p>
						<h4>5、索引的数据结构</h4>
						<h5><strong>哈希索引</strong></h5>
						<p>只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此<strong>哈希索引不支持范围查找和排序的功能</strong>。</p>
						<h5><strong>全文索引</strong></h5>
						<p>FULLTEXT（全文）索引，仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。</p>
						<h5><strong>BTree索引</strong></h5>
						<p>BTree的数据结构是平衡多叉树，节点包含的数据数称为度。</p>
						<p>BTree的特点：</p>
						<ul>
						<li>每个叶子节点的高度一样（通常为3-5）；</li>
						<li>每个叶子节点有N-1个key和N个指针组成；</li>
						<li>叶子节点指正都为null；</li>
						<li>非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的数据；</li>

						</ul>
						<h5>B+Tree索引</h5>
						<p>B+Tree索引是BTree的一个变种。</p>
						<p>B+Tree与BTree的区别：</p>
						<ul>
						<li>B+Tree中的非叶子结点不存储数据，只存储键值；</li>
						<li>B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址；</li>
						<li>B+Tree的每个非叶子节点由n个键值key和n个指针point组成；</li>

						</ul>
						<h5>B+Tree对比BTree的优点</h5>
						<p><strong>磁盘读写代价更低</strong></p>
						<p>磁盘一次读取一页数据（4k），非叶子节点不包含原始数据，能够存储跟多的数据，这样可以保证树的高度更低，I/O操作更少。</p>
						<p>存储引擎的设计专家巧妙的利用了外存（磁盘）的存储结构，即磁盘的最小存储单位是扇区（sector），而操作系统的块（block）通常是整数倍的sector，操作系统以页（page）为单位管理内存，一页（page）通常默认为4K，数据库的页通常设置为操作系统页的整数倍，因此索引结构的节点被设计为一个页的大小，然后利用外存的“预读取”原则，每次读取的时候，把整个节点的数据读取到内存中，然后在内存中查找，已知内存的读取速度是外存读取I/O速度的几百倍。</p>
						<p><strong>查询速度更稳定</strong></p>
						<p>由于B+Tree非叶子节点不存储数据（data），因此所有的数据都要查询至叶子节点，而叶子节点的高度都是相同的，因此所有数据的查询速度都是一样的，均衡的。</p>
						<h4>6、数据库的范式</h4>
						<p>第一范式（1NF）：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</p>
						<p>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</p>
						<p>第三范式（3NF）：必须先满足第二范式（2NF），要求：表中的每一列只与主键<strong>直接相关</strong>而不是间接相关，（表中的每一列只能依赖于主键）；</p>
						<h4>7、数据库表的连接</h4>
						<p>各种连接的韦恩图：</p>
						<p>1）INNER JOIN （内连接）
						内连接是一种一一映射关系，就是两张表都有的才能显示出来
						用韦恩图表示是两个集合的交集，如图：</p>
						<p><img src="https://img-blog.csdn.net/20180329111900524?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMDQ1NDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" referrerpolicy="no-referrer" alt="img"></p>
						<p>2）LEFT JOIN （左连接）
						左连接是左边表的所有数据都有显示出来，右边的表数据只显示共同有的那部分，没有对应的部分只能补空显示，所谓的左边表其实就是指放在left join的左边的表
						用韦恩图表示如下：</p>
						<p><img src="https://img-blog.csdn.net/20180329134737651?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMDQ1NDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" referrerpolicy="no-referrer" alt="img"></p>
						<p>3）RIGHT JOIN（右连接）
						右连接正好是和左连接相反的，这里的右边也是相对right join来说的，在这个右边的表就是右表
						用韦恩图表示如下：</p>
						<p><img src="https://img-blog.csdn.net/20180329135224420?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMDQ1NDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" referrerpolicy="no-referrer" alt="img"></p>
						<p>4）OUTER JOIN（外连接、全连接）
						查询出左表和右表所有数据，但是去除两表的重复数据
						韦恩图表示如下：</p>
						<p><img src="https://img-blog.csdn.net/20180329162047416?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMDQ1NDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" referrerpolicy="no-referrer" alt="img"></p>
						<p>5）LEFT JOIN EXCLUDING INNER JOIN（左连接不包含内连接）
						这个查询是只查询左边表有的数据，共同有的也不查出来</p>
						<p><img src="https://img-blog.csdn.net/20180329145952942?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMDQ1NDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" referrerpolicy="no-referrer" alt="img"></p>
						<p>6）RIGHT JOIN EXCLUDING INNER JOIN（右连接不包含内连接）
						这个查询是只查询右边表有的数据，共同有的也不查出来
						韦恩图表示如下：</p>
						<p><img src="https://img-blog.csdn.net/20180329150015408?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMDQ1NDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" referrerpolicy="no-referrer" alt="img"></p>
						<p>7）OUTER JOIN EXCLUDING INNER JOIN（外连接不包含内连接）
						意思就是查询左右表各自拥有的那部分数据
						韦恩图表示如下：</p>
						<p><img src="https://img-blog.csdn.net/20180329150032685?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQyMDQ1NDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" referrerpolicy="no-referrer" alt="img"></p>
						<h4>8、存储过程</h4>
						<p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。进一步地说，存储过程是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。存储过程具有以下特点：</p>
						<ul>
						<li>存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次，所以使用存储过程可提高数据库执行效率；</li>
						<li>当SQL语句有变动时，可以只修改数据库中的存储过程而不必修改代码；</li>
						<li>减少网络传输，在客户端调用一个存储过程当然比执行一串SQL传输的数据量要小；</li>
						<li>通过存储过程能够使没有权限的用户在控制之下间接地存取数据库，从而确保数据的安全。</li>

						</ul>
						<p><strong>使用:</strong></p>
						<pre><code class='language-mysql' lang='mysql'>create procedure porcedureName () 
						begin 
							select name from user; 
						end; 
						</code></pre>
						<h4>9、数据库锁</h4>
						<h5>9.1、锁的分类</h5>
						<p>1）按锁的粒度划分，可分为表级锁、行级锁、页级锁（mysql）
						2）按锁级别划分，可分为共享锁、排他锁
						3）按使用方式划分，可分为乐观锁、悲观锁 </p>
						<p><strong>表级锁（偏向于读）</strong></p>
						<ul>
						<li>优缺点</li>

						</ul>
						<blockquote><p>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低</p>
						</blockquote>
						<ul>
						<li>支持引擎：MyISAM、MEMORY、InnoDB</li>
						<li>表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）</li>

						</ul>
						<p><strong>行级锁（偏向于写）</strong></p>
						<ul>
						<li>优缺点</li>

						</ul>
						<blockquote><p>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
						</blockquote>
						<ul>
						<li>支持引擎：InnoDB</li>
						<li>行级锁定分为行共享读锁（共享锁）与行独占写锁（排他锁）</li>

						</ul>
						<p><strong>页级锁</strong></p>
						<p>对于行级锁与表级锁的折中，开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>
						<p><strong>共享锁（读锁）</strong></p>
						<p>共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。（只能读不能改）
						用法：SELECT … LOCK IN SHARE MODE;前边必须使用begin</p>
						<p><strong>排他锁（写锁）</strong></p>
						<p>一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。
						可以直接通过select …from…查询数据，因为普通查询没有任何锁机制。
						用法：SELECT … FOR UPDATE;前边必须使用begin（锁一行）</p>

					</article>
						
					
                        <!--h2 class="article-title">Introduction to pursuit</h2>

                        <p class="article-meta">Posted on <time datetime="2017-05-14">14 May</time> by <a href="#" rel="author">Joe Bloggs</a></p>

                        <p>Welcome to pursuit, a free CSS3 &amp; HTML5 responsive web template from <a href="#" title="ZyPOP">ZyPOP</a>. This template is completely <strong>free</strong> to use permitting a link remains back to  <a href="#" title="ZyPOP">ZyPOP</a>.</p>

                        <p> Should you wish to use this template unbranded you can buy a template license from our website for 8.00 GBP, this will allow you remove all branding related to our site, for more information about this see below.</p>	

                        <p>This template has been tested in:</p>

                        <ul>
                            <li>Firefox</li>
                            <li>IE / Edge</li>
                            <li>Chrome</li>
                            <li>Safari</li>
                            <li>iOS / Android</li>
                        </ul>

                    </p>

                </div>        
            </div> 
        </main>


        <!-- Footer -->
        <footer class="footer">
            <div class="footer-bottom">
                    <p class="text-center">Copyright &copy; 2019.Company name All rights reserved.</p>
                    <p class="text-center"><a href="#top" target="_self">返回顶部</a></p>
            </div>
            
        </footer>



        <!-- Bootcamp JavaScript -->
        <!-- jQuery first, then Popper.js, then Bootstrap JS -->
        <script src="js/jquery-3.2.1.slim.min.js"></script>
        <script src="js/popper.min.js"></script>
        <script src="js/bootstrap.min.js"></script>

    </body>
</html>